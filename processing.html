<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Digital Media Art Workshop</title>
    
<link href="css/site.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/highlight.default.css" media="screen" rel="stylesheet" type="text/css" />
  
<script src="js/jquery.js"></script>
<script src="js/showdown.js" type="text/javascript"></script>

<link rel="stylesheet" href="css/github.css">
<script src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
<!--
Write the markdown code below.
A guide to markdown syntax is at http://daringfireball.net/projects/markdown/
-->

<div style="display: none" id="sourcetext">

# Processing

&lt;img src="img/P.jpg" align="right" &gt;

> Processing is an open source programming language and integrated development environment (IDE) built for the electronic arts and visual design communities with the purpose of teaching the fundamentals of computer programming in a visual context, and to serve as the foundation for electronic sketchbooks. One of the stated aims of Processing is to act as a tool to get non-programmers started with programming, through the instant gratification of visual feedback. [wikipedia](http://en.wikipedia.org/wiki/Processing_(programming_language))

Processing focuses on creating "images, animations, and interactions" within an integrated textual programming environment. Although it was designed as a sketching and pedagogical tool, today "there are tens of thousands of students, artists, designers, researchers, and hobbyists who use Processing for learning, prototyping, and production." [Processing](http://www.processing.org/)

It is one of the most widely used platforms for digital visual arts and creative coding projects today. It is multi-OS and can run in a web browser, it has been extended with many great libraries, integrates well with [Arduino](http://www.arduino.cc/) for hardware sensors, and has been [ported to JavaScript](http://processingjs.org/) for better integration in today's browsers.

### Getting Processsing

Processing is the open software and supports cross-platform. Please download and install from [http://processing.org/](http://processing.org/).

If you have any problems installing it, you can always try [running it in the browser](http://sketch.processing.org/) -- not everything will work, but enough to get started.

### Support materials and references

Two recommended textbooks:

- *Getting Started with Processing*  
Casey Reas and Ben Fry. Published June 2010, O'Reilly Media. 208 pages. Paperback.
- *Learning Processing: A Beginner's Guide to Programming Images, Animation, and Interaction*  
Daniel Shiffman. Published August 2008, Morgan Kaufmann. 450 pages. Paperback.

In addition there are numerous help, tutorial, example and reference files in the Processing software, on the [Processing website](http://www.processing.org) and [elsewhere](http://www.google.com). There are huge amounts of example code and projects available on [OpenProcessing](http://openprocessing.org/) for example.

----

# Getting Started

Take a look at the first [Processing tutorial](http://www.processing.org/learning/gettingstarted/) -- this is also linked from the Processing Help menu. 

Here's our first program. In processing, programs are also known as *sketches*:

```
void setup() {
  size(400, 400);
}

void draw() {
  line(100, 250, 300, 250);
}
```

- **Don't copy & paste code**: type it by hand! Doing things by hand requires full attention to detail and develops vital subconscious skills; these will help you enormously when you start inventing your own projects.

- **Watch out for punctuation**: especially the three different kinds of brackets ```() {} []``` and the semicolon ```;``` at the end of each line!

- Be careful to **indent the code properly**. Indent any lines between a block start curly bracket ```{``` and a block end curly bracket ```}```. You can use *Tools->Auto Format* (or command-T keys) to do this automatically. Although the code may work, indenting is really helpful to understand the code, and is a good habit to get into.

We can run this program, or sketch, by clicking on the triangle run button in Processing, or pressing Command-R; it should open a window looking something like this:

![first sketch](img/first_sketch.png) 

If you make a mistake in writing the code, the program will probably fail to run (or if you get lucky, it might run and do something unexpected...). A message will display in the *console* area, which might help you find the error.

## What does it mean? 

Maybe you can guess what this does? 

### What is *setup* and *draw*?

We can see there are two parts to our program; the first part goes ```void setup()...``` and the second part goes ```void draw()...```. These parts of the program are called **functions**, because they describe what the program can do ("how it functions"). The function called ```draw``` makes sense; Processing is primarily an environment for making programs that draw graphics. The function called ```setup``` does whatever work is needed in order to set up the system to start drawing; in this case it defines the size of the canvas. 

The ```setup``` and ```draw``` function names have special meaning in Processing; they will be automatically *called* by the Processing environment at special times:

- when a program (sketch) starts, Processing calls the ```setup``` function once.
- after that, Processing calls the ```draw``` function several times a second, so that we can make moving images just like animators do.

So whatever we put inside ```setup``` will happen once when the sketch starts, and whatever we put in ```draw``` will happen whenever Processing updates the canvas. 

> Technical detail: A function collects a series of **instructions** together in a sequence, rather like a recipe. So the ```draw``` function is a recipe for making images. 

Let's add some more instructions, more code, into ```draw```:

```
void setup() {
  size(400, 400);
}

void draw() {
  line(100, 250, 300, 250);
  line(200, 200, 200, 220);
}
```

So what do ```size``` and ```line``` do? They are **built-in** functions, which are predefined by Processing. There are lots and lots of built-in functions, for all kinds of purposes. They are the basic ingredients for a recipe, and they are all listed online in the [Processing Language API](http://www.processing.org/reference/). 

Let's look there to see what ```size``` means. We can either search for it manually in the list, or we can select and right-click on the word ```size``` and choose **Find in Reference**. 

There's a lot of information there, because although we start simple, Processing can get quite powerful; but usually the most important parts are *Description*, *Syntax* and *Parameters*. The syntax tells us the correct ways(s) to write the function, and the parameters explain how to make the function behave in different ways. 

Here are the important parts:

> **Description:** Defines the dimension of the display window in units of pixels...   
> **Syntax:** ```size(w, h)```  
> **Parameters:** ```w``` int: width of the display window in units of pixels  
> **Parameters:** ```h``` int: height of the display window in units of pixels

OK, so for our code, ```size(400, 400);```, the ```400``` corresponds to ```w``` and ```400``` corresponds to ```h``` in the syntax.  So, our ```size(400, 400);``` means:

> Define the dimension of the display with a height of 400 pixels and 400 pixels.

## But, what's a pixel?

You can think of it that all graphics rendering in Processing are drawn on good old graph paper. The screen is a grid of *picture elements*, or **pixels** for short, like the boxes in graph paper. Each pixel can have one color. All images you see on the computer are made of pixels. To draw a line, you can *fill in* a row of pixels:

![Coordinate system](img/coordinates.jpg)

> To tell the computer which box to start drawing from, or to finish drawing, you need to identify the box by it's position on the canvas. We use **X** for the horizontal position along the page (the column), and **Y** for the vertical position down the page (the row). Every box has a unique X,Y pair to identify it; this is called the coordinate. Almost all drawing in Processing is defined in terms of **pixel positions (coordinates)** and **pixel sizes (dimensions)**.

There's a great tutorial about this [here](http://www.processing.org/learning/drawing/). 

OK, so now we know that when our program starts, it runs our ```setup``` function, which contains the ```size(400, 400)``` instruction, which creates a canvas that has 400 rows and 400 columns of pixels. 

We can probably make a good guess as to what the ```line``` calls mean too! 

If we check the reference, it says the ```line(...)``` function "draws a line to the screen", and the parameters set the 'x' (horizontal) and 'y' (vertical) coordinates of the start position, followed by the 'x' (horizontal) and 'y' (vertical) coordinates of the end position, of the line. So our first line goes from position 200, 200 to psotion 200, 220. Our second line goes from position 100, 250 to position 300, 250. 

Try changing some of these numbers and running the sketch to see what it does. Drawing like this is part of the reason why the ancestor of Processing was called *Design by Numbers*. 

OK, now we understand what the code is doing, we should add our understanding to our document, by adding *comments*. Any line can be a comment by adding two slashes at the start:

```
// what to do the when the program first starts up:
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
}

// what to do when the canvas should be drawn:
void draw() {
  // draw a line from 100, 250 to 300, 250:
  line(100, 250, 300, 250);
  // draw a line from 200, 200 to 200, 220:
  line(200, 200, 200, 220);
}
```

Your code will still work even if you don't indent it propery or add comments, but you will have a far more difficult time understanding what it does when you look at it again a week or two later, or if you show it to somebody else (e.g. the professors...) Many wise programmers say: **"code is more often read than written"**. 

## Algorithmic painter

What else can we draw besides lines? Take a look at the reference to understand the ```rect``` and ```ellipse``` functions. Let's try adding an ellipse:

```
// what to do the when the program first starts up:
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
}

// what to do when the canvas should be drawn:
void draw() {
  // draw a line from 100, 250 to 300, 250:
  line(100, 250, 300, 250);
  // draw a line from 200, 200 to 200, 220:
  line(200, 200, 200, 220);
  // draw an ellipse centered at 200, 200
  // with width 300 and height 300:
  ellipse(200, 200, 300, 300);
}
```

Wait -- what happened to our lines?

The problem is that when we draw the ellipse, it *draws over the top* of our lines. Processing draws with the *Painter's algorithm*, which means that each new thing drawn goes over the top of the one before, like oil painting on a canvas. It happened to use because the ```ellipse``` call happens *after* the ```line``` calls in our ```draw``` function (remember, the content of a function is like a recipe; each line happens after the line above it). OK, so we can fix this by changing the order:


```
// what to do the when the program first starts up:
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
}

// what to do when the canvas should be drawn:
void draw() {
  // first, draw an ellipse centered at 200, 200
  // with width 300 and height 300:
  ellipse(200, 200, 300, 300);
  
  // now draw some lines:
  // draw a line from 100, 250 to 300, 250:
  line(100, 250, 300, 250);
  // draw a line from 200, 200 to 200, 220:
  line(200, 200, 200, 220);
}
```

Okay. Can you make a face?

You can add ```smooth();``` to the ```setup``` function, to make the image look nicer, and ```strokeWeight(3);``` in ```setup``` to change the line thickness (weight, as in how hard your pen is pressed...). 

Try using ```fill(0);``` and ```fill(255);``` to paint in black or white, in different places within the ```draw``` function.

> The ```fill``` function "sets the color used to fill shapes". The matching syntax it uses here is ```fill(gray)```, where gray in this case is 255, which is a "number specifying value between white and black". In Processing, ```0``` is black, ```255``` is white, and numbers in between are different shades of gray. 

So ```fill(255);``` sets the color used to fill shapes to be white. That means, any objects drawn after this call will have white filling.

Remember, if anything doesn't work, try changing the order, or *commenting it out* by putting ```//``` in front of it.

----

## First Interaction 

Let's bring this to life. Try this:

```
// what to do the when the program first starts up:
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
  // make the lines look smooth:
  smooth();
  // make the lines look fat:
  strokeWeight(3);
}

// what to do when the canvas should be drawn:
void draw() {
  // paint in white:
  fill(255);
  // first draw the head:
  // an ellipse centered at 200, 200
  // with width 300 and height 300:
  ellipse(200, 200, 300, 300);
  
  // now draw some features:
  // paint in black:
  fill(0);
  
  // mouth
  // draw a rect from 100, 250 
  // with width 200 and height 20:
  rect(100, 250, 200, 20);
  
  // nose
  // draw a line from 200, 200 to 200, 220:
  line(200, 200, 200, 220);
  
  // eyes
  // more ellipses for the eyes:
  ellipse(130, 150, 80, 80);
  ellipse(270, 150, 80, mouseY);
}
```

At the end, the height of the last two ellipses are set to whatever the value of ```mouseY``` is. Again, we can look it up in the reference: "The system *variable* ```mouseY``` always contains the current horizontal coordinate of the mouse".

### What is a *system variable*?

> A variable is a container for data that can change while a program runs. Even though the data changes, the name of the variable stays the same, and that's how we can use it. The value of the variable ```mouseY``` gets changed automatically by Processing (because it is a *system* variable); the value stored in ```mouseY``` is automatically set to the value of the current mouse vertical position. 

There's ```mouseX``` of course -- see if you can find a good place to use it!

Since the values of ```mouseX``` and ```mouseY``` are always numbers, we can also use them wherever we could use numbers. This means we can do a bit of mathematics with them. For example, we can add and subtract, multiply or divide them. We can use this to make the eyes less sensitive:

```
// what to do the when the program first starts up:
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
  // make the lines look smooth:
  smooth();
  // make the lines look fat:
  strokeWeight(3);
}

// what to do when the canvas should be drawn:
void draw() {
  // paint in white:
  fill(255);
  // first draw the head:
  // an ellipse centered at 200, 200
  // with width 300 and height 300:
  ellipse(200, 200, 300, 300);
  
  // now draw some features:
  // paint in black:
  fill(0);
  
  // mouth
  // draw a rect from 100, 250 
  // with width 200 and height 20:
  rect(100, 250, 200, mouseX / 10);
  
  // nose
  // draw a line from 200, 200 to 200, 220:
  line(200, 200, 200, 220);
  
  // eyes
  // more ellipses for the eyes:
  ellipse(130, 150, 80, mouseY / 5);
  ellipse(270, 150, 80, mouseY / 5);
}
```

# Assignment 1

Make your own character, using the basic shapes. Look in the Processing reference to find out how to use them all:

- ```line```
- ```rect```
- ```ellipse```
- ```point```
- ```triangle```
- ```quad```
- ```arc```

The character should respond to the mouse in an interesting way.

Comment each line to explain what you think it does. In the description when you submit the work, explain your motivation, and any questions you have or any aspect you want to get feedback about.

----

# Week 2

## Making variables

We used the word *variable* already to describe ```mouseX```, and we said:

> A variable is a container for data that can change while a program runs. Even though the data changes, the name of the variable stays the same, and that's how we can use it. 

There are other variables built-in to Processing (called *system variables*) like this:

- ```width``` is the width of the canvas in pixels
- ```height``` is the height of the canvas in pixels

### Width and height

Using ```width``` and ```height``` is a really good idea. Let's say we want to make a sketch with a line through the middle:

```
void setup() {
	size(400, 200);
}

void draw() {
	// clear the canvas to light grey:
   	background(200);
   	
	// draw a horizontal line through the canvas:
	line(0, 100, 400, 100);
}
```

Works great. But what if we now want to make the window bigger?

```
void setup() {
	size(600, 300);
}

void draw() {
	// clear the canvas to light grey:
   	background(200);
   	
	// draw a horizontal line through the canvas:
	line(0, 100, 400, 100);
}
```

No good -- now we also need to change the ```line``` parameters, and any other drawing parameters we might have had in a more complex sketch. But if we change those numbers to be *relative* to the size of the canvas, this problem disappears:

```
void setup() {
	size(600, 300);
}

void draw() {
	// clear the canvas to light grey:
   	background(200);
   	
	// draw a horizontal line through the canvas:
	line(0, height/2, width, height/2);
}
```

Perfect!

### Make your own variables

So a variable is like a box to store a value, which has a name. We can use this name to see what value the variable contains, like we did with ```mouseX``` and ```width```. But we can also create variables ourselves, and put different values into them as the program runs.

Before we can use a variable, we need to *declare* it. In Processing, like many programming languages, a variable also has a *type*. You can think of it as what kind of box it is. A variable of a particular type can only hold values of that same type. Some of the basic types are ```int``` (whole numbers), ```float``` (decimal numbers), ```color```, etc. You can't put a color into a float-type variable, you need to put it into a color-type variable. So when we declare a variable, we give it a *name* and a *type*:

```
// declare a new variable called 'i', whose type is 'int' (a whole number)
int i;

// set the value of the variable:
i = 1;
```

This can be combined into a single instruction like this:

``` 
// declare a new variable 'i' of type 'int' and initialize it to the value one:
int i = 1;
```

And here's how we use it:

```
// read the value of the variable:
print(i);	// -> 1

// change the value of the variable:
x = 10;

// read the value of the variable:
print(i);	// -> 10

// assign a decimal number to x:
x = 0.5; 	// -> error: "cannot convert from float to int"
```

The error happens because in Processing, and many other languages, although the *value* of a variable can change, the type cannot.


### Growth

How does a worm grow? It keeps adding new segments on the end. It starts with one segment, then adds another to get two, and another, and another, as time goes on. Let's make a worm.

```
// declare a variable for the number of worm segments:
int wormsize;

// let's start by seeing what a worm with ten segments looks like:
void setup() {
	size(600, 300);
	// set an initial value for the wormsize:
	wormsize = 10;
}

// and draw it:
void draw() {
	// clear the canvas to light grey:
   	background(200);
   	
	// draw a horizontal line through the canvas:
	line(0, height/2, wormsize, height/2);
}
```

Okay, so let's see it grow. When it starts, the ```wormsize``` should be 1, since it only has one segment. As time passes, we need to change the ```wormsize``` variable by adding one more segment. That means that the new ```wormsize``` will be the old ```wormsize``` plus one. We write that in Processing like this:

```
// growth: the new wormsize will be the old wormsize plus one:
wormsize = wormsize + 1;
```

Pretty weird looking, especially if you've ever done any algebra before! What you have to remember is that in Processing (and many other programming languages), the single ```=``` symbol does not mean *equals*, it means *assignment*. The variable on the left-hand side (LHS) is changed to the value of the right-hand side (RHS). Processing first calculates the value on the RHS, and copies that into the variable on the LHS. So the RHS represents the past, and the LHS represents the future. That's why we can use the same variable name on both sides.

Okay, so since this needs to happen "as time passes", we need to put it into the ```draw``` function, which is the only function that happens continually.

```
// declare a variable for the number of worm segments:
int wormsize;

// let's start by seeing what a worm with ten segments looks like:
void setup() {
	size(600, 300);
	// set an initial value for the wormsize:
	wormsize = 10;
}

// and draw it:
void draw() {
	// clear the canvas to light grey:
	background(200);
   	
	// growth: the new wormsize will be the old wormsize plus one:
	wormsize = wormsize + 1;

	// draw a horizontal line through the canvas:
	line(0, height/2, wormsize, height/2);
}
```

Notice how the wormsize variable keeps its value between each call to ```draw```. Variables give us a way to make our program *remember* things we care about, things we compute now and want to use later, things that *persist through time*. We call it **state**, because a variable captures one aspect of a program that could be in one condition or another (but not both at the same time), and remains that way until changed. 

After a while, the worm persists in growing so long that it doesn't fit on the screen anymore, and our sketch becomes rather boring.

Some options:

- Restart the worm when the mouse is clicked
- Restart the worm if it gets to the edge

### Restart the worm when the mouse is clicked

Let's break this down into the components:

1. "Restart the worm..."
2. "...when the mouse is clicked"

#### 1. "Restart the worm..."

To restart the worm we must put all of the changeable conditions back to their original configuration; that mean putting the variables back to the initial values. In this case we only have one variable, ```wormsize```, and the initial value was one, so to restart the worm we need to add this code:

```
// reset the worm conditions to initial configuration:
wormsize = 1;
```

But where should we add it?

#### 2. "...when the mouse is clicked"

To respond to a mouse click, we should use another special function that is automatically called by Processing, just like ```setup``` and ```draw```. If you create a function called ```mouseClicked```, Processing will call it whenever the mouse button is clicked. Let's add this to our program:

```
void mouseClicked() {
	print("mouse was clicked!");
}
```

Now clicking on the sketch will make this message appear in the console. When the mouse is clicked, Processing enters our ```mouseClicked``` function and performs whatever instructions it contains. So we need to put instructions in here to reset our worm to the initial size again:

```
void mouseClicked() {
	// when the mouse is clicked, the worm will restart from birth again:
	wormsize = 0;
}
```

### Restart the worm if it gets to the edge

Again, we can break this into the two parts "Restart the worm" and "when it gets to the end". We know how to restart the worm, but how do we detect that it has reached the end? There's no built-in function of Processing to help us here. Instead, we are going to have to keep checking the state of the worm as it grows, until the possible *condition* of "it gets to the end" becomes true. If this condition becomes true, then we should restart the worm. 

In Processing we can express this idea by using a special construction called ```if```. Each ```if``` structure has a **condition**, and a block of **instructions** that it will perform only when the condition is true:

```
// print 'success' in the console if the value of the variable 'guess' equals 7:
if (guess == 7) {
	print("success");
}
```

Whatever we put into the condition section should result in either a ```true``` or ```false``` value. If it results in ```true```, then the instructions inside will be performed. We can also add an ```else``` section, to provide instructions for what to do if the condition is ```false```:

```
// print 'success' in the console if the value of the variable 'guess' equals 7:
if (guess == 7) {
	print("success");
} else {
	print("bad guess, try again");
}
```

Back to the problem of the worm: we have to keep checking the state of the worm, and **if** it reaches the end, **then** reset it to the initial state, **else** increase the worm size by one. We have to check the condition continually, so we put it inside ```draw```:

```
void draw() {
  // clear the canvas to light grey:
  background(200);

  if (wormsize > width) {
    // worm reached the end, reset to initial value:
    wormsize = 1;
  } 
  else {
    // growth: the new wormsize will be the old wormsize plus one:
    wormsize = wormsize + 1;
  }

  // draw a horizontal line through the canvas:
  line(0, height/2, wormsize, height/2);
}
```

# Week 3: Abstraction with transformations and functions

Last week we learned that we can use ```width``` and ```height``` to easily support different canvas resolutions for our growing worm. But what if we want to draw the face from week 1? 

```lua
void setup() {
  // create a canvas of 400 wide by 400 high pixels:
  size(400, 400);
  
  // drawing style:
  smooth();
  strokeWeight(3);
}

void draw() {
  // paint in white:
  fill(255);
  // head:
  ellipse(200, 200, 300, 300);		
  
  // paint in black:
  fill(0);
  // mouth
  rect(100, 250, 200, 20);
  // nose
  line(200, 200, 200, 220);
  // eyes
  ellipse(130, 150, 80, 80);
  ellipse(270, 150, 80, 80);
}
```

Each one of these drawing commands needs to be modified into expressions of ```width``` and ```height```, which is a bit silly. And what if we wanted the face to move around the canvas, maybe like the worm, or maybe following the mouse? The code would get really complicated:

```lua
void draw() {
	// paint in white:
	fill(255);
	// head:
	ellipse(width/2, height/2, 300, 300);		
	
	// paint in black:
	fill(0);
	// mouth
	rect(width/2 - 100, height/2 + 50, 200, 20);
	// nose
	line(width/2, height/2, width/2, height/2 + 20);
	// eyes
	ellipse(width/2 - 70, height/2 - 50, 80, 80);
	ellipse(width/2 + 70, height/2 - 50, 80, 80);
}
```

Or to follow the mouse, as a 'face painter':

```lua
void draw() {
	// paint in white:
	fill(255);
	// head:
	ellipse(mouseX, mouseY, 300, 300);		
	
	// paint in black:
	fill(0);
	// mouth
	rect(mouseX - 100, mouseY + 50, 200, 20);
	// nose
	line(mouseX, mouseY, mouseX, mouseY + 20);
	// eyes
	ellipse(mouseX - 70, mouseY - 50, 80, 80);
	ellipse(mouseX + 70, mouseY - 50, 80, 80);
}
```

### Translations of space

Processing offers a much simpler way of doing this:

```lua
void draw() {
	// move to the center of canvas:
	translate(width/2, height/2);
	
	// paint in white:
	fill(255);
	// head:
	ellipse(0, 0, 300, 300);		
	
	// paint in black:
	fill(0);
	// mouth
	rect(-100, 50, 200, 20);
	// nose
	line(0, 0, 0, 20);
	// eyes
	ellipse(-70, -50, 80, 80);
	ellipse( 70, -50, 80, 80);
}
```

You could think of ```translate``` as meaning changing the 'start point' (in mathematical terms, the *"origin"*) of drawing. Or you could think of it as moving the underlying "graph paper" that we are drawing onto, like in the Processing.org [Transform2D tutorial](http://processing.org/learning/transform2d/). 

> The word *translate* is also taken from mathematics; it *translates* points in one space (such as Processing drawing commands) to points in another space (such as the pixels on screen). 

Notice that ```width``` and ```height``` are only used once. The more drawing we do, the more useful this is. If we are drawing a complex object using lots of drawing commands, all the positions will be *relative* to the center of the object, rather than  to the top-left corner of the screen. And now it's really easy to change -- for example, we could try using ```translate(mouseX, mouseY)``` instead. 

Or maybe re-use something from our worm:

```lua
int wormsize;

void setup() {
	size(800, 600);
	wormsize = 1;
}

void draw() {
	// reset or grow worm:
	if (wormsize > width) {
		// worm reached the end, reset to initial value:
		background();
		wormsize = 1;
	} 
	else {
		// growth: the new wormsize will be the old wormsize plus one:
		wormsize = wormsize + 1;
	}

	// move to the worm position:
	translate(wormsize, height/2);
	
	// paint in white:
	fill(255);
	// head:
	ellipse(0, 0, 300, 300);		
	
	// paint in black:
	fill(0);
	// mouth
	rect(-100, 50, 200, 20);
	// nose
	line(0, 0, 0, 20);
	// eyes
	ellipse(-70, -50, 80, 80);
	ellipse( 70, -50, 80, 80);
}
```

### Transformers of transformers

The ```translate``` command isn't the only way to change the coordinate system (the underlying graph paper...). We can also change the size of the coordinate system (graph paper) with the ```scale``` command, and rotate with the ```rotate``` command. 

The ```scale``` command scales all positions and lengths that come after it, and the ```rotate``` command rotates all positions that come after it around the current origin. It's easier to understand this by making it.

Try putting ```scale(0.25);``` after the ```translate``` command in the face-worm sketch above; notice how the face got 25% smaller.

Rotations are a little trickier; like most programming languages, Processing measures angles in **radians** rather than **degrees**. This makes a lot of math much easier, but isn't so intuitive if you've never used radians before. 

![Radians](img/UnitCircle.png)

> There are 360 degrees in a circle. There are 2*Pi radians in a circle. So 180 degrees == Pi radians, 90 degrees == Pi/2 radians, etc. What is Pi? Pi is the ratio of the diameter of a circle (the distance between opposite edges) and the circumference (the distance around the border). It is a strange but incredibly important number whose value is roughly 3.141592653589793... 

You can always convert a number in degrees to a number in radians using the ```radians``` function, like this:

```lua
	// pick a random angle between -45 degrees and +45 degrees
	// convert this into radians
	// and use it to rotate all future drawing commands:
	rotate( radians( random(-45, 45) ) );
```

Here's an example of combining transformations together with some of the user-variable concepts from the worm, but making it remember X and Y position and direction, rather than length; and allowing it to wander like a robot dragging a rubber stamp:

```
// robot has a X and Y position, and direction angle:
float robotx;
float roboty;
float robota;

void setup() {
  size(300, 600); 
  
  // initialize robot variables
  robotx = width/2;
  roboty = height/2;
  robota = 0;
}

void draw() {
  // move the robot
  robotx = robotx + random(-3, 3);
  roboty = roboty + random(-3, 4);
  robota = robota + radians(random(-12, 12));
  
  // what to do if robot leaves bottom edge:
  if (roboty > height) {
     roboty = 0;
  }
  
  // transform Processing into a robot-centric space:
  translate(robotx, roboty);
  rotate(robota);
  scale(random(1, 1.2));
  
  // draw robot:
  rect(-10, -10, 20, 20, 4);
  point(-4, -2);
  point(4, -2);
  line(-4, 4, 4, 4);
}

void mouseClicked() {
	// restart robot at mouse position
	robotx = mouseX;
	roboty = mouseY;
}
```

### Functions

To draw many different faces or robots at different sizes, positions and rotations, we could copy & paste the draw commands, but that seems like going back to the problem of when you change one, you have to change them all... We can **abstract** a series of commands into a re-usable sequence by creating our own **functions**:

```lua
void drawFace() {
	// paint in white:
	fill(255);
	// head:
	ellipse(0, 0, 300, 300);		
	
	// paint in black:
	fill(0);
	// mouth
	rect(-100, 50, 200, 20);
	// nose
	line(0, 0, 0, 20);
	// eyes
	ellipse(-70, -50, 80, 80);
	ellipse( 70, -50, 80, 80);
}
```

And now we can use this function to draw many faces:

```lua
void draw() {
	// start drawing at middle of screen
	translate(width/2, height/2);
	// scale down to 10%:
	scale(0.1);
	
	// draw a face:
	drawFace();
	
	// move to the right & draw another face:
	translate(100, 0);
	drawFace();
	
	// move to the right & draw another face:
	translate(100, 0);
	drawFace();
	
	// move to the right & draw another face:
	translate(100, 0);
	drawFace();
	
	// move to the right & draw another face:
	translate(100, 0);
	drawFace();
}
```

Notice how the transforms accumulate. (Try replacing the 100's with mouseX, or seconds(), or random(), or a variable of your own, like wormsize...)

### The matrix of transformations

Obviously there's some hidden state at work here.

> We met hidden state already with the ```fill``` and ```stroke``` functions. When we set ```fill(100)```, everything we draw will be filled with dark grey until the next ```fill``` call changes the *fill color*. Processing carries this *fill color*, and several other hidden state parameters, around with it as it runs our sketches. Processing has a lot of these hidden state parameters, and we have to keep that in mind when trying to understand what our sketches are doing. In a way, changing hidden state changes how Processing works into a different program: calling ```fill(255)``` turns Processing into a white-filling program for a while. Calling ```translate(width/2, height/2)``` turns Processing into a program that draws relative to the center of the canvas. 

*However*, ```translate```, ```scale``` and ```rotate``` do not replace the previous values; instead they accumulate on top of each other into a hidden state called the **transformation matrix**, which is a fancy name for how we get from the coordinate system in which we are currently drawing to the coordinate system of the actual output pixels.

Try putting ```scale(0.25);``` before or after the ```translate``` command in the face-worm sketch. Notice that if the ```scale``` comes first, it also scales the ```translate```! Or try adding ```translate(random(-3, 3), random(-3, 3))``` after or before the other ```translate```, and see what that does. We're about ready for some generative design...

On the other hand, what if we didn't want to accumulate? We could manually do the opposite transform (e.g. translate-left followed by translate-right), but wouldn't it be easier if we could tell Processing to just "forget" the last few transformations?

### Push and pop

How can we 'undo' a transformation and get back to the original system? In Processing we can do this using the ```pushMatrix()``` and ```popMatrix()``` commands. Each *push* remembers the *transformation matrix* when it is called, and at the next *pop* this *transformation matrix* is restored.

With this we can easily now create ideal visual forms, and then create instances of these forms with different position, scale and rotation, however we please. We'll come back to this idea next week.

> Also see the L-System and Robot Arms in the Processing Examples

## Assignment 3: build an ANTustrator. 

Cf. Maeda: DBN, reactive drawing; and Haberli's [Dynadraw](http://processing.org/exhibition/works/dynadraw/))

This will be a non-standard drawing program, with some dynamic aspect. 

For example:

- Chooses different brushes from time to time
- Brushes change shape, or color, etc.
- Brushes sometimes wander about by themselves
- Brushes orbit the mouse in some way
- Brushes have child brushes and grandchild brushes that orbit their parents
- Etc.
- You could make changes of behavior when the mouse is clicked or keys are pressed. 

Here's a tip: if you want the background to slowly fade out, add this at the start of your draw():

```lua
void draw() {
	// set fill color to be partly transparent:
	fill(200, 100);
	// draw a rect over everything:
	rect(0, 0, width, height);
	// set the fill color to be opaque again:
	fill(100);
	
	// draw stuff here:
	// 
	//
}
```

----

# Submitting your work

You can submit your projects to our [classroom page on OpenProcessing](http://www.openprocessing.org/classroom/2619). You'll first need to register with a username; please use your school ID and name for your username, e.g.:

```
123456_grahamw
```

To submit a sketch to your OpenProcessing portfolio:

- Go to [OpenProcessing.org](http://www.openprocessing.org/) and sign in.
- Go to the *my portfolio* page and click on *create new sketch*
- Copy your Processing code from the Processing editor and paste it into the webpage, and click *save*
- Add a title for your work, and a description if you like.
- Again click *save*

To submit one of your portfolio works to the classroom assignment sub-collection:

- Go to [the classroom collection](http://www.openprocessing.org/classroom/2619)
- Click on the *Select a sketch* button
- Click on the sketch you want to submit
- Now move this sketch into the proper assignment sub-collection.

Make sure your code is commented with your original idea. Avoid repeating the same code as much as possible.

Assignments are due every Wednesday at 3pm. 

</div>
<!--
We can create other variables in our programs too, and read and change the data they contain. To do this, we need to learn another detail first. In Processing, and many other programming languages, variables also have a **type**, which never changes. The type of a variable defines what *kinds* of data it can contain. For example, **int** type variables always contain integers, which are whole numbers like 0, 1, 2, 3 etc. They cannot contain any other kind of data. So whenever we introduce a new variable name to the program (we *declare* it), we also need to tell Processing what type of data it will contain.
-->
<div id="wrapper">
	
	<div class="header">
		
		<h1>ANT3010</h1>		
		<a href="index.html">Overview</a><br/>
		<a href="dmaworkshop.pdf">Syllabus</a><br/>
		<br/>
		<a href="processing.html">Processing</a><br/>
		<br/>
		<a href="max.html">Max/MSP/Jitter</a><br/>
	</div>
	<div class="section">
		<script type="text/javascript">
		//var converter = new Markdown.Converter();
		var converter = new Showdown.converter();
		document.write(converter.makeHtml($('#sourcetext').text()));
		</script>
	</div>
	
	<div class="footer">Haru Ji & Graham Wakefield, 2013</div>
	
</div>
</body>
</html>